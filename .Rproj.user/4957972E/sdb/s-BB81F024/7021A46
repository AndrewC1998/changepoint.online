{
    "contents" : "\tsetClass(\"cpt\",slots=list(data.set=\"ts\", cpttype=\"character\", method=\"character\", \ttest.stat=\"character\",pen.type=\"character\",pen.value=\"numeric\",minseglen=\"numeric\",cpts=\"numeric\",ncpts.max=\"numeric\",param.est=\"list\",date=\"character\",version=\"character\"),prototype=prototype(date=date(),version=as(packageVersion(\"changepoint\"),'character')))\n\n\tsetClass(\"cpt.reg\",slots=list(data.set=\"matrix\", cpttype=\"character\", method=\"character\", test.stat=\"character\",pen.type=\"character\",pen.value=\"numeric\",minseglen=\"numeric\",cpts=\"numeric\",ncpts.max=\"numeric\",param.est=\"list\",date=\"character\",version=\"character\"),prototype=prototype(cpttype=\"regression\",date=date(),version=as(packageVersion(\"changepoint\"),\"character\")))\n  \n#   setClass(\"cpt\", representation(), prototype())\n# # cpts is the optimal segementation\n#   \n  setClass(\"cpt.range\",slots=list(cpts.full=\"matrix\", pen.value.full=\"numeric\"), prototype=prototype(), contains=\"cpt\")\n  # cpts.full is the entire matrix\n  # pen.value.full (beta) values as an extra slot (vector)\n\n# retrival functions for slots\n\tif(!isGeneric(\"data.set\")) {\n\t\tif (is.function(\"data.set\")){\n\t\t\tfun <- data.set\n\t\t}\n\t  else {fun <- function(object){\n\t\t\t\tstandardGeneric(\"data.set\")\n\t\t\t}\n\t\t}\n\t\tsetGeneric(\"data.set\", fun)\n\t}\n\tsetMethod(\"data.set\",\"cpt\",function(object) coredata(object@data.set))\n\tsetMethod(\"data.set\",\"cpt.reg\",function(object) coredata(object@data.set))\n\n\tif(!isGeneric(\"data.set.ts\")) {\n\t  if (is.function(\"data.set.ts\")){\n\t    fun <- data.set.ts\n\t  }\n\t  else {fun <- function(object){\n\t    standardGeneric(\"data.set.ts\")\n\t  }\n\t  }\n\t  setGeneric(\"data.set.ts\", fun)\n\t}\n\tsetMethod(\"data.set.ts\",\"cpt\",function(object) object@data.set)\n\n  if(!isGeneric(\"cpttype\")) {\n\t\tif (is.function(\"cpttype\")){\n\t\t\tfun <- cpttype\n\t\t}\n\t\telse {fun <- function(object){\n\t\t\t\tstandardGeneric(\"cpttype\")\n\t\t\t}\n\t\t}\n\t\tsetGeneric(\"cpttype\", fun)\n\t}\n\tsetMethod(\"cpttype\",\"cpt\",function(object) object@cpttype)\n\tsetMethod(\"cpttype\",\"cpt.reg\",function(object) object@cpttype)\n\n\tif(!isGeneric(\"method\")) {\n\t\tif (is.function(\"method\")){\n\t\t\tfun <- method\n\t\t}\n\t\telse {fun <- function(object){\n\t\t\t\tstandardGeneric(\"method\")\n\t\t\t}\n\t\t}\n\t\tsetGeneric(\"method\", fun)\n\t}\n\tsetMethod(\"method\",\"cpt\",function(object) object@method)\n\tsetMethod(\"method\",\"cpt.reg\",function(object) object@method)\n\t\n\t# distribution remains for backwards compatability, changed to test.stat version 1.0\n\tif(!isGeneric(\"distribution\")) {\n\t  if (is.function(\"distribution\")){\n\t    fun <- distribution\n\t  }\n\t  else {fun <- function(object){\n\t    standardGeneric(\"distribution\")\n\t  }\n\t  }\n\t  setGeneric(\"distribution\", fun)\n\t}\n\tsetMethod(\"distribution\",\"cpt\",function(object) object@test.stat)\n\tsetMethod(\"distribution\",\"cpt.reg\",function(object) object@test.stat)\n\t\n  if(!isGeneric(\"test.stat\")) {\n\t\tif (is.function(\"test.stat\")){\n\t\t\tfun <- test.stat\n\t\t}\n\t\telse {fun <- function(object){\n\t\t\t\tstandardGeneric(\"test.stat\")\n\t\t\t}\n\t\t}\n\t\tsetGeneric(\"test.stat\", fun)\n\t}\n\tsetMethod(\"test.stat\",\"cpt\",function(object) object@test.stat)\n\tsetMethod(\"test.stat\",\"cpt.reg\",function(object) object@test.stat)\n\t\n\tif(!isGeneric(\"pen.type\")) {\n\t\tif (is.function(\"pen.type\")){\n\t\t\tfun <- pen.type\n\t\t}\n\t\telse {fun <- function(object){\n\t\t\t\tstandardGeneric(\"pen.type\")\n\t\t\t}\n\t\t}\n\t\tsetGeneric(\"pen.type\", fun)\n\t}\n\tsetMethod(\"pen.type\",\"cpt\",function(object) object@pen.type)\n\tsetMethod(\"pen.type\",\"cpt.reg\",function(object) object@pen.type)\n\t\n\tif(!isGeneric(\"pen.value\")) {\n\t\tif (is.function(\"pen.value\")){\n\t\t\tfun <- pen.value\n\t\t}\n\t\telse {fun <- function(object){\n\t\t\t\tstandardGeneric(\"pen.value\")\n\t\t\t}\n\t\t}\n\t\tsetGeneric(\"pen.value\", fun)\n\t}\n\tsetMethod(\"pen.value\",\"cpt\",function(object) object@pen.value)\n\tsetMethod(\"pen.value\",\"cpt.reg\",function(object) object@pen.value)\n\n\tif(!isGeneric(\"pen.value.full\")) {\n\t  if (is.function(\"pen.value.full\")){\n\t    fun <- pen.value.full\n\t  }\n\t  else {fun <- function(object){\n\t    standardGeneric(\"pen.value.full\")\n\t  }\n\t  }\n\t  setGeneric(\"pen.value.full\", fun)\n\t}\n\tsetMethod(\"pen.value.full\",\"cpt.range\",function(object) object@pen.value.full)\n\n  if(!isGeneric(\"minseglen\")) {\n\t  if (is.function(\"minseglen\")){\n\t    fun <- minseglen\n\t  }\n\t  else {fun <- function(object){\n\t    standardGeneric(\"minseglen\")\n\t  }\n\t  }\n\t  setGeneric(\"minseglen\", fun)\n\t}\n\tsetMethod(\"minseglen\",\"cpt\",function(object) object@minseglen)\n\t\n\tif(!isGeneric(\"cpts\")) {\n\t\tif (is.function(\"cpts\")){\n\t\t\tfun <- cpts\n\t\t}\n\t\telse {fun <- function(object){\n\t\t\t\tstandardGeneric(\"cpts\")\n\t\t\t}\n\t\t}\n\t\tsetGeneric(\"cpts\", fun)\n\t}\n\tsetMethod(\"cpts\",\"cpt\",function(object) object@cpts[-length(object@cpts)])\n\tsetMethod(\"cpts\",\"cpt.reg\",function(object) object@cpts[-length(object@cpts)])\n\t\n\tif(!isGeneric(\"cpts.full\")) {\n\t  if (is.function(\"cpts.full\")){\n\t    fun <- cpts.full\n\t  }\n\t  else {fun <- function(object){\n\t    standardGeneric(\"cpts.full\")\n\t  }\n\t  }\n\t  setGeneric(\"cpts.full\", fun)\n\t}\n\tsetMethod(\"cpts.full\",\"cpt.range\",function(object) object@cpts.full)\n\n  if(!isGeneric(\"cpts.ts\")) {\n\t\tif (is.function(\"cpts.ts\")){\n\t\t\tfun <- cpts.ts\n\t\t}\n\t\telse {fun <- function(object){\n\t\t\t\tstandardGeneric(\"cpts.ts\")\n\t\t\t}\n\t\t}\n\t\tsetGeneric(\"cpts.ts\", fun)\n\t}\n\tsetMethod(\"cpts.ts\",\"cpt\",function(object) index(data.set.ts(object))[cpts(object)] )\n\n\tif(!isGeneric(\"ncpts.max\")) {\n\t\tif (is.function(\"ncpts.max\")){\n\t\t\tfun <- ncpts.max\n\t\t}\n\t\telse {fun <- function(object){\n\t\t\t\tstandardGeneric(\"ncpts.max\")\n\t\t\t}\n\t\t}\n\t\tsetGeneric(\"ncpts.max\", fun)\n\t}\n\tsetMethod(\"ncpts.max\",\"cpt\",function(object) object@ncpts.max)\n\tsetMethod(\"ncpts.max\",\"cpt.reg\",function(object) object@ncpts.max)\n\n\tif(!isGeneric(\"param.est\")) {\n\t\tif (is.function(\"param.est\")){\n\t\t\tfun <- param.est\n\t\t}\n\t\telse {fun <- function(object){\n\t\t\t\tstandardGeneric(\"param.est\")\n\t\t\t}\n\t\t}\n\t\tsetGeneric(\"param.est\", fun)\n\t}\n\tsetMethod(\"param.est\",\"cpt\",function(object) object@param.est)\n\tsetMethod(\"param.est\",\"cpt.reg\",function(object) object@param.est)\n\n\n  setMethod(\"coef\",\"cpt\",function(object) object@param.est)\n\tsetMethod(\"coef\",\"cpt.reg\",function(object) object@param.est)\n\t\n# ncpts function\n\tif(!isGeneric(\"ncpts\")) {\n\t\tif (is.function(\"ncpts\")){\n\t\t\tfun <- ncpts\n\t\t}\n\t\telse {fun <- function(object){\n\t\t\t\tstandardGeneric(\"ncpts\")\n\t\t\t}\n\t\t}\n\t\tsetGeneric(\"ncpts\", fun)\n\t}\n\tsetMethod(\"ncpts\",\"cpt\",function(object) length(cpts(object)))\n\tsetMethod(\"ncpts\",\"cpt.reg\",function(object) length(cpts(object)))\n\n# seg.len function\n\tif(!isGeneric(\"seg.len\")) {\n\t\tif (is.function(\"seg.len\")){\n\t\t\tfun <- seg.len\n\t\t}\n\t\telse {fun <- function(object){\n\t\t\t\tstandardGeneric(\"seg.len\")\n\t\t\t}\n\t\t}\n\t\tsetGeneric(\"seg.len\", fun)\n\t}\n\tsetMethod(\"seg.len\",\"cpt\",function(object){object@cpts-c(0,object@cpts[-length(object@cpts)])})\n\tsetMethod(\"seg.len\",\"cpt.reg\",function(object){object@cpts-c(0,object@cpts[-length(object@cpts)])})\n#i.e. if there is a changepoint in the data, return segment length. If not, return length of the data\n\t\n  # nseg function\n\tif(!isGeneric(\"nseg\")) {\n\t  if (is.function(\"nseg\")){\n\t    fun <- nseg\n\t  }\n\t  else {fun <- function(object){\n\t    standardGeneric(\"nseg\")\n\t  }\n\t  }\n\t  setGeneric(\"nseg\", fun)\n\t}\n\tsetMethod(\"nseg\",\"cpt\",function(object){ncpts(object)+1})\n\tsetMethod(\"nseg\",\"cpt.reg\",function(object){ncpts(object)+1})\n  \n  \n# replacement functions for slots\n\tsetGeneric(\"data.set<-\", function(object, value) standardGeneric(\"data.set<-\"))\n\tsetReplaceMethod(\"data.set\", \"cpt\", function(object, value) {\n\t\tif(is.ts(value)){object@data.set <- value}else{object@data.set <- ts(value)}\n\t\treturn(object)\n\t})\n\tsetReplaceMethod(\"data.set\", \"cpt.reg\", function(object, value) {\n\t\tobject@data.set <- value\n\t\treturn(object)\n\t})\n\t\n\tsetGeneric(\"cpttype<-\", function(object, value) standardGeneric(\"cpttype<-\"))\n\tsetReplaceMethod(\"cpttype\", \"cpt\", function(object, value) {\n\t\tobject@cpttype <- value\n\t\treturn(object)\n\t})\n\tsetReplaceMethod(\"cpttype\", \"cpt.reg\", function(object, value) {\n\t\tobject@cpttype <- value\n\t\treturn(object)\n\t})\n\t\n\tsetGeneric(\"method<-\", function(object, value) standardGeneric(\"method<-\"))\n\tsetReplaceMethod(\"method\", \"cpt\", function(object, value) {\n\t\tobject@method <- value\n\t\treturn(object)\n\t})\n\tsetReplaceMethod(\"method\", \"cpt.reg\", function(object, value) {\n\t\tobject@method <- value\n\t\treturn(object)\n\t})\n\t\n  # distribution remains for backwards compatability, changed to test.stat version 1.0\n\tsetGeneric(\"distribution<-\", function(object, value) standardGeneric(\"distribution<-\"))\n\tsetReplaceMethod(\"distribution\", \"cpt\", function(object, value) {\n\t  object@test.stat <- value\n\t  return(object)\n\t})\n\tsetReplaceMethod(\"distribution\", \"cpt.reg\", function(object, value) {\n\t  object@test.stat <- value\n\t  return(object)\n\t})\n\n  setGeneric(\"test.stat<-\", function(object, value) standardGeneric(\"test.stat<-\"))\n\tsetReplaceMethod(\"test.stat\", \"cpt\", function(object, value) {\n\t\tobject@test.stat <- value\n\t\treturn(object)\n\t})\n\tsetReplaceMethod(\"test.stat\", \"cpt.reg\", function(object, value) {\n\t\tobject@test.stat <- value\n\t\treturn(object)\n\t})\n\t\n\tsetGeneric(\"pen.type<-\", function(object, value) standardGeneric(\"pen.type<-\"))\n\tsetReplaceMethod(\"pen.type\", \"cpt\", function(object, value) {\n\t\tobject@pen.type <- value\n\t\treturn(object)\n\t})\n\tsetReplaceMethod(\"pen.type\", \"cpt.reg\", function(object, value) {\n\t\tobject@pen.type <- value\n\t\treturn(object)\n\t})\n\t\n\tsetGeneric(\"pen.value<-\", function(object, value) standardGeneric(\"pen.value<-\"))\n\tsetReplaceMethod(\"pen.value\", \"cpt\", function(object, value) {\n\t\tobject@pen.value <- value\n\t\treturn(object)\n\t})\n\tsetReplaceMethod(\"pen.value\", \"cpt.reg\", function(object, value) {\n\t\tobject@pen.value <- value\n\t\treturn(object)\n\t})\n\n\tsetGeneric(\"minseglen<-\", function(object, value) standardGeneric(\"minseglen<-\"))\n\tsetReplaceMethod(\"minseglen\", \"cpt\", function(object, value) {\n\t  object@minseglen <- value\n\t  return(object)\n\t})\n\tsetReplaceMethod(\"minseglen\", \"cpt.range\", function(object, value) {\n\t  object@minseglen <- value\n\t  return(object)\n\t})\n\tsetReplaceMethod(\"minseglen\", \"cpt.reg\", function(object, value) {\n\t  object@minseglen <- value\n\t  return(object)\n\t})\n\t\n\tsetGeneric(\"cpts<-\", function(object, value) standardGeneric(\"cpts<-\"))\n\tsetReplaceMethod(\"cpts\", \"cpt\", function(object, value) {\n\t  if((cpttype(object)==\"meanar\")|(cpttype(object)==\"trendar\")){\n\t    n=length(object@data.set)-1\n\t  }\n\t  else{n=length(object@data.set)}\n\t  \n    if(value[length(value)]==n){object@cpts <- value}\n    else{\t\tobject@cpts <- c(value,n)  }\n\t\treturn(object)\n\t})\n\tsetReplaceMethod(\"cpts\", \"cpt.reg\", function(object, value) {\n\t  if(value[length(value)]==nrow(object@data.set)){object@cpts <- value}\n\t  else{  \tobject@cpts <- c(value,nrow(object@data.set))  }\n\t  return(object)\n\t})\n\n\tsetGeneric(\"ncpts.max<-\", function(object, value) standardGeneric(\"ncpts.max<-\"))\n\tsetReplaceMethod(\"ncpts.max\", \"cpt\", function(object, value) {\n\t\tobject@ncpts.max <- value\n\t\treturn(object)\n\t})\n\tsetReplaceMethod(\"ncpts.max\", \"cpt.reg\", function(object, value) {\n\t\tobject@ncpts.max <- value\n\t\treturn(object)\n\t})\n\t\n\tsetGeneric(\"param.est<-\", function(object, value) standardGeneric(\"param.est<-\"))\n\tsetReplaceMethod(\"param.est\", \"cpt\", function(object, value) {\n\t\tobject@param.est <- value\n\t\treturn(object)\n\t})\n\tsetReplaceMethod(\"param.est\", \"cpt.reg\", function(object, value) {\n\t\tobject@param.est <- value\n\t\treturn(object)\n\t})\n  \n\tsetGeneric(\"cpts.full<-\", function(object, value) standardGeneric(\"cpts.full<-\"))\n\tsetReplaceMethod(\"cpts.full\", \"cpt.range\", function(object, value) {\n\t  object@cpts.full <- value\n\t  return(object)\n\t})\n\tsetGeneric(\"pen.value.full<-\", function(object, value) standardGeneric(\"pen.value.full<-\"))\n\tsetReplaceMethod(\"pen.value.full\", \"cpt.range\", function(object, value) {\n\t  object@pen.value.full <- value\n\t  return(object)\n\t})\n# \tsetGeneric(\"pen.value.input<-\", function(object, value) standardGeneric(\"pen.value.input<-\"))\n# \tsetReplaceMethod(\"pen.value.input\", \"cpt\", function(object, value) {\n# \t  object@pen.value.input <- value\n# \t  return(object)\n# \t})\n  \n\n# parameter functions\n\tsetGeneric(\"param\", function(object,...) standardGeneric(\"param\"))\n\tsetMethod(\"param\", \"cpt\", function(object,shape,...) {\t\t\t\n\t\tparam.mean=function(object){\n\t\t\tcpts=c(0,object@cpts)\n\t\t\t#nseg=length(cpts)-1\n\t\t\tdata=data.set(object)\n\t\t\ttmpmean=NULL\n\t\t\tfor(j in 1:nseg(object)){\n\t\t\t\ttmpmean[j]=mean(data[(cpts[j]+1):(cpts[j+1])])\n\t\t\t}\n\t\t\treturn(tmpmean)\n\t\t}\n\t\tparam.var=function(object){\n\t\t\tcpts=c(0,object@cpts)\n\t\t\t#nseg=length(cpts)-1\n\t\t\tdata=data.set(object)\n\t\t\tseglen=seg.len(object)\n\t\t\ttmpvar=NULL\n\t\t\tfor(j in 1:nseg(object)){\n\t\t\t\ttmpvar[j]=var(data[(cpts[j]+1):(cpts[j+1])])\n\t\t\t}\n\t\t\ttmpvar=tmpvar*(seglen-1)/seglen # correctly for the fact that the MLE estimate is /n but the var function is /n-1\n\t\t\treturn(tmpvar)\n\t\t}\n\t\tparam.scale=function(object,shape){\n\t\t\tcpts=c(0,object@cpts)\n\t\t\t#nseg=length(cpts)-1\n\t\t\tdata=data.set(object)\n\t\t\ty=c(0,cumsum(data))\n\t\t\ttmpscale=NULL\n\t\t\tfor(j in 1:nseg(object)){\n\t\t\t\ttmpscale[j]=(y[(cpts[j+1]+1)]-y[(cpts[j]+1)])/((cpts[j+1]-cpts[j])*shape)\n\t\t\t}\n\t\t\treturn(tmpscale)\t\t\t\n\t\t}\n\t\tparam.trend=function(object){\n\t\t  cpts=c(0,object@cpts)\n\t\t  seglen=seg.len(object)\n\t\t  data=data.set(object)\n\t\t  n=length(data)\n\t\t  sumstat=cbind(cumsum(c(0,data)),cumsum(c(0,data*c(1:n))))\n\t\t  cptsumstat=matrix(sumstat[object@cpts+1,]-sumstat[c(0,cpts(object))+1,],ncol=2)\n\t\t  cptsumstat[,2]=cptsumstat[,2]-cptsumstat[,1]*c(0,cpts(object)) # i.e. creating newx3\n\t\t  \n\t\t  thetaS=(2*cptsumstat[,1]*(2*seglen + 1) - 6*cptsumstat[,2]) / (2*seglen*(2*seglen + 1) - 3*seglen*(seglen+1))\n\t\t  thetaT=(6*cptsumstat[,2])/((seglen+1)*(2*seglen+1)) + (thetaS * (1-((3*seglen)/((2*seglen)+1))))\n\t\t  return(cbind(thetaS,thetaT))\n\t\t}\n\t\tparam.meanar=function(object){\n\t\t  seglen=seg.len(object)\n\t\t  data=data.set(object)\n\t\t  n=length(data)-1\n\t\t  sumstat=cbind(cumsum(c(0,data[-1])),cumsum(c(0,data[-(n+1)])),cumsum(c(0,data[-1]*data[-(n+1)])),cumsum(c(0,data[-1]^2)),cumsum(c(0,data[-(n+1)]^2)))\n\t\t  cptsumstat=matrix(sumstat[object@cpts+1,]-sumstat[c(0,cpts(object))+1,],ncol=5)\n\t\t  beta2=(2*seglen*cptsumstat[,3]-cptsumstat[,1]*cptsumstat[,2])/(2*seglen*cptsumstat[,5]*(1-cptsumstat[,2]^2));\n\t\t  beta1=(2*cptsumstat[,1]-beta2*cptsumstat[,2])/(2*seglen);\n\t\t  \n\t\t  return(cbind(beta1,beta2))\n\t\t}\n\t\tparam.trendar=function(object){\n\t\t  seglen=seg.len(object)\n\t\t  data=data.set(object)\n\t\t  n=length(data)-1\n\t\t  sumstat=cbind(cumsum(c(0,data[-1])),cumsum(c(0,data[-(n+1)])),cumsum(c(0,data[-1]*data[-(n+1)])),cumsum(c(0,data[-1]*c(1:n))),cumsum(c(0,data[-(n+1)]*c(0:(n-1)))),cumsum(c(0,data[-1]^2)),cumsum(c(0,data[-(n+1)]^2)))\n\t\t  cptsumstat=matrix(sumstat[object@cpts+1,]-sumstat[c(0,cpts(object))+1,],ncol=7)\n\t\t  cptsumstat[,4]=cptsumstat[,4]-cptsumstat[,1]*c(0,cpts(object)) # i.e. creating newx4\n\t\t  cptsumstat[,5]=cptsumstat[,5]-cptsumstat[,2]*c(0,cpts(object)) # i.e. creating newx5\n\t\t  betatop=seglen*(seglen-1)*(seglen*(seglen-1)*cptsumstat[,3] + 2*(2*seglen+1)*cptsumstat[,1]*(cptsumstat[,5]-seglen*cptsumstat[,2]) + 6*cptsumstat[,4]*(cptsumstat[,2]-cptsumstat[,5]))\n\t\t  betabottom=seglen*(seglen-1)*cptsumstat[,7] + 2*(2*seglen+1)*cptsumstat[,2]*(seglen*cptsumstat[,2]-cptsumstat[,5]) + 6*cptsumstat[,5]*(cptsumstat[,5]-cptsumstat[,2]);\n\t\t  beta=betatop/betabottom;  \n\t\t  thetajpo=(6*(seglen+2)*(cptsumstat[,4]-beta*cptsumstat[,5]))/((seglen+1)*(2*seglen+1)) - 2*(cptsumstat[,1]-beta*cptsumstat[,2])\n\t\t  thetaj=(2*(2*seglen+1)*(cptsumstat[,1]-beta*cptsumstat[,2])-6*(cptsumstat[,4]-beta*cptsumstat[,5]))/(seglen-1)\n\t\t  \n\t\t  return(cbind(beta,thetajpo,thetaj))\n\t\t}\n\t\tif(cpttype(object)==\"mean\"){\n\t\t\tparam.est(object)<-list(mean=param.mean(object))\n\t\t}\n\t\telse if(cpttype(object)==\"variance\"){\n\t\t\tparam.est(object)<-list(variance=param.var(object))\n\t\t}\n\t\telse if(cpttype(object)==\"mean and variance\"){\n\t\t\tif(test.stat(object)==\"Normal\"){\n\t\t\t\tparam.est(object)<-list(mean=param.mean(object),variance=param.var(object))\n\t\t\t}\n\t\t\telse if(test.stat(object)==\"Gamma\"){\n\t\t\t\tparam.est(object)<-list(scale=param.scale(object,shape=shape),shape=shape)\n\t\t\t}\n\t\t\telse if(test.stat(object)==\"Exponential\"){\n\t\t\t\tparam.est(object)<-list(rate=1/param.mean(object))\n\t\t\t}\n\t\t\telse if(test.stat(object)==\"Poisson\"){\n\t\t\t  param.est(object)<-list(lambda=param.mean(object))\n\t\t\t}\n\t\t\telse{\n\t\t\t\tstop(\"Unknown test statistic for a change in mean and variance\")\n\t\t\t}\n\t\t}\n\t\telse if(cpttype(object)==\"trend\"){\n\t\t  if(test.stat(object)==\"Normal\"){\n\t\t    tmp=param.trend(object)\n\t\t    param.est(object)<-list(thetaS=tmp[,1],thetaT=tmp[,2])\n\t\t  }\n\t\t  else{\n\t\t    stop(\"Unknown test statistic for a change in trend\")\n\t\t  }\n\t\t}\n\t\telse if(cpttype(object)==\"trendar\"){\n\t\t  if(test.stat(object)==\"Normal\"){\n\t\t    tmp=param.trendar(object)\n\t\t    param.est(object)<-list(beta=tmp[,1],thetajpo=tmp[,2],thetaj=tmp[,3])\n\t\t  }\n\t\t  else{\n\t\t    stop(\"Unknown test statistic for a change in trend+ar\")\n\t\t  }\n\t\t}\n\t\telse if(cpttype(object)==\"meanar\"){\n\t\t  if(test.stat(object)==\"Normal\"){\n\t\t    tmp=param.meanar(object)\n\t\t    param.est(object)<-list(beta1=tmp[,1],beta2=tmp[,2])\n\t\t  }\n\t\t  else{\n\t\t    stop(\"Unknown test statistic for a change in mean+ar\")\n\t\t  }\n\t\t}\n\t\telse{\n\t\t\tstop(\"Unknown changepoint type, must be 'mean', 'variance', 'mean and variance', 'trend', 'meanar' or 'trendar'.\")\n\t\t}\n\t\treturn(object)\n\t})\n\n\tsetMethod(\"param\", \"cpt.range\", function(object,ncpts=NA,shape,...) {\n\t  if(is.na(ncpts)){\n\t    cpts=c(0,object@cpts)\n\t  }\n\t  else{\n\t    ncpts.full=apply(cpts.full(object),1,function(x){sum(x>0,na.rm=TRUE)})\n\t    row=try(which(ncpts.full==ncpts),silent=TRUE)\n\t    if(class(row)=='try-error'){\n\t      stop(\"Your input object doesn't have a segmentation with the requested number of changepoints.\")\n\t    }\n\t    cpts=c(0,cpts.full(object)[row,1:ncpts],length(data.set(object)))\n\t  }\n\t  \n\t \tparam.mean=function(object,cpts){\n\t \t  nseg=length(cpts)-1\n\t    data=data.set(object)\n\t    tmpmean=NULL\n\t    for(j in 1:nseg){\n\t      tmpmean[j]=mean(data[(cpts[j]+1):(cpts[j+1])])\n\t    }\n\t    return(tmpmean)\n\t  }\n\t  param.var=function(object,cpts){\n\t    nseg=length(cpts)-1\n\t    data=data.set(object)\n\t    seglen=seg.len(object)\n\t    tmpvar=NULL\n\t    for(j in 1:nseg){\n\t      tmpvar[j]=var(data[(cpts[j]+1):(cpts[j+1])])\n\t    }\n\t    tmpvar=tmpvar*(seglen-1)/seglen\n\t    return(tmpvar)\n\t  }\n\t  param.scale=function(object,cpts,shape){\n\t    nseg=length(cpts)-1\n\t    data=data.set(object)\n\t    y=c(0,cumsum(data))\n\t    tmpscale=NULL\n\t    for(j in 1:nseg){\n\t      tmpscale[j]=(y[(cpts[j+1]+1)]-y[(cpts[j]+1)])/((cpts[j+1]-cpts[j])*shape)\n\t    }\n\t    return(tmpscale)\t\t\t\n\t  }\n\t  param.trend=function(object){\n\t    cpts=c(0,object@cpts)\n\t    seglen=seg.len(object)\n\t    data=data.set(object)\n\t    n=length(data)\n\t    sumstat=cbind(cumsum(c(0,data)),cumsum(c(0,data*c(1:n))))\n\t    cptsumstat=matrix(sumstat[object@cpts+1,]-sumstat[c(0,cpts(object))+1,],ncol=2)\n\t    cptsumstat[,2]=cptsumstat[,2]-cptsumstat[,1]*c(0,cpts(object)) # i.e. creating newx3\n\t    \n\t    thetaS=(2*cptsumstat[,1]*(2*seglen + 1) - 6*cptsumstat[,2]) / (2*seglen*(2*seglen + 1) - 3*seglen*(seglen+1))\n\t    thetaT=(6*cptsumstat[,2])/((seglen+1)*(2*seglen+1)) + (thetaS * (1-((3*seglen)/((2*seglen)+1))))\n\t    return(cbind(thetaS,thetaT))\n\t  }\n\t  param.meanar=function(object){\n\t    seglen=seg.len(object)\n\t    data=data.set(object)\n\t    n=length(data)-1\n\t    sumstat=cbind(cumsum(c(0,data[-1])),cumsum(c(0,data[-(n+1)])),cumsum(c(0,data[-1]*data[-(n+1)])),cumsum(c(0,data[-1]^2)),cumsum(c(0,data[-(n+1)]^2)))\n\t    cptsumstat=matrix(sumstat[object@cpts+1,]-sumstat[c(0,cpts(object))+1,],ncol=5)\n\t    beta2=(2*seglen*cptsumstat[,3]-cptsumstat[,1]*cptsumstat[,2])/(2*seglen*cptsumstat[,5]*(1-cptsumstat[,2]^2));\n\t    beta1=(2*cptsumstat[,1]-beta2*cptsumstat[,2])/(2*seglen);\n\t    \n\t    return(cbind(beta1,beta2))\n\t  }\n\t  param.trendar=function(object){\n\t    seglen=seg.len(object)\n\t    data=data.set(object)\n\t    n=length(data)-1\n\t    sumstat=cbind(cumsum(c(0,data[-1])),cumsum(c(0,data[-(n+1)])),cumsum(c(0,data[-1]*data[-(n+1)])),cumsum(c(0,data[-1]*c(1:n))),cumsum(c(0,data[-(n+1)]*c(0:(n-1)))))\n\t    cptsumstat=matrix(sumstat[object@cpts+1,]-sumstat[c(0,cpts(object))+1,],ncol=7)\n\t    cptsumstat[,4]=cptsumstat[,4]-cptsumstat[,1]*c(0,cpts(object)) # i.e. creating newx4\n\t    cptsumstat[,5]=cptsumstat[,5]-cptsumstat[,2]*c(0,cpts(object)) # i.e. creating newx5\n\t    betatop=seglen*(seglen-1)*(seglen*(seglen-1)*cptsumstat[,3] + 2*(2*seglen+1)*cptsumstat[,1]*(cptsumstat[,5]-seglen*cptsumstat[,2]) + 6*cptsumstat[,4]*(cptsumstat[,2]-cptsumstat[,5]))\n\t    betabottom=seglen*(seglen-1)*cptsumstat[,7] + 2*(2*seglen+1)*cptsumstat[,2]*(seglen*cptsumstat[,2]-cptsumstat[,5]) + 6*cptsumstat[,5]*(cptsumstat[,5]-cptsumstat[,2]);\n\t    beta=betatop/betabottom;  \n\t    thetajpo=(6*(seglen+2)*(cptsumstat[,4]-beta*cptsumstat[,5]))/((seglen+1)*(2*seglen+1)) - 2*(cptsumstat[,1]-beta*cptsumstat[,2])\n\t    thetaj=(2*(2*seglen+1)*(cptsumstat[,1]-beta*cptsumstat[,2])-6*(cptsumstat[,4]-beta*cptsumstat[,5]))/(seglen-1)\n\t    \n\t    return(cbind(beta,thetajpo,thetaj))\n\t  }\n\t  \n\t  if(cpttype(object)==\"mean\"){\n\t    param.est<-list(mean=param.mean(object,cpts))\n\t  }\n\t  else if(cpttype(object)==\"variance\"){\n\t    param.est<-list(variance=param.var(object,cpts))\n\t  }\n\t  else if(cpttype(object)==\"mean and variance\"){\n\t    if(test.stat(object)==\"Normal\"){\n\t      param.est<-list(mean=param.mean(object,cpts),variance=param.var(object,cpts))\n\t    }\n\t    else if(test.stat(object)==\"Gamma\"){\n\t      param.est<-list(scale=param.scale(object,cpts,shape=shape),shape=shape)\n\t    }\n\t    else if(test.stat(object)==\"Exponential\"){\n\t      param.est<-list(rate=1/param.mean(object,cpts))\n\t    }\n\t    else if(test.stat(object)==\"Poisson\"){\n\t      param.est<-list(lambda=param.mean(object,cpts))\n\t    }\n\t    else{\n\t      stop(\"Unknown test statistic for a change in mean and variance\")\n\t    }\n\t  }\n\t  else if(cpttype(object)==\"trend\"){\n\t    if(test.stat(object)==\"Normal\"){\n\t      tmp=param.trend(object)\n\t      param.est(object)<-list(thetaS=tmp[,1],thetaT=tmp[,2])\n\t    }\n\t    else{\n\t      stop(\"Unknown test statistic for a change in trend\")\n\t    }\n\t  }\n\t  else if(cpttype(object)==\"trendar\"){\n\t    if(test.stat(object)==\"Normal\"){\n\t      tmp=param.trendar(object)\n\t      param.est(object)<-list(beta=tmp[,1],thetajpo=tmp[,2],thetaj=tmp[,3])\n\t    }\n\t    else{\n\t      stop(\"Unknown test statistic for a change in trend+ar\")\n\t    }\n\t  }\n\t  else if(cpttype(object)==\"meanar\"){\n\t    if(test.stat(object)==\"Normal\"){\n\t      tmp=param.meanar(object)\n\t      param.est(object)<-list(beta1=tmp[,1],beta2=tmp[,2])\n\t    }\n\t    else{\n\t      stop(\"Unknown test statistic for a change in mean+ar\")\n\t    }\n\t  }\n\t  else{\n\t    stop(\"Unknown changepoint type, must be 'mean', 'variance', 'mean and variance', 'trend', 'meanar' or 'trendar'\")\n\t  }\n\t  if(is.na(ncpts)){\n\t    param.est(object)=param.est\n\t    return(object)\n\t  }\n\t  out=new('cpt.range')\n\t  param.est(out)=param.est\n\t  return(out)\n\t})\n\t\n\tsetMethod(\"param\", \"cpt.reg\", function(object,shape,...) {\t\t\t\n\t\tparam.norm=function(object){\n\t\t\tcpts=c(0,object@cpts)\n\t\t#\tnseg=length(cpts)-1 #nseg(object)\n\t\t\tdata=data.set(object)\n\t\t\tp=ncol(data)-1\n\t\t\ttmpbeta=matrix(NA,ncol=p,nrow=nseg(object))\n\t\t\ttmpsigma=rep(NA,nseg(object))\n\t\t\tfor(j in 1:nseg(object)){\n\t\t\t  formula=paste('-1+data[',cpts[j]+1,':',cpts[j+1],',2]',sep='')\n\t\t\t  if(p>1){\n\t\t\t    for(i in 2:p){\n\t\t\t      formula=paste(formula,'+data[',(cpts[j]+1),':',cpts[j+1],',',i+1,']',sep='')\n\t\t\t    }\n\t\t\t  }\n\t\t\t  tmpfit=eval(parse(text=paste('lm(data[',(cpts[j]+1),':',cpts[j+1],',1]~',formula,')',sep='')))\n\t\t\t  tmpbeta[j,]=tmpfit$coefficients\n\t\t\t  tmpsigma[j]=var(tmpfit$residuals)\n\t\t\t}\n\t\t\treturn(list(beta=tmpbeta,sig2=tmpsigma))\n\t\t}\n\t\tif(test.stat(object)==\"Normal\"){\n\t\t\tparam.est(object)<-param.norm(object)\n\t\t}\n\t\telse{\n\t\t\tstop(\"Unknown test statistic, must be 'Normal'\")\n\t\t}\n\t\treturn(object)\n\t})\n\n# summary functions\n\tsetMethod(\"summary\",\"cpt\",function(object){\n\t    cat(\"Created Using changepoint version\",object@version,'\\n')\n\t    cat(\"Changepoint type      : Change in\",cpttype(object),'\\n')\n\t    cat(\"Method of analysis    :\",method(object),\"\\n\")\n\t    cat(\"Test Statistic  :\", test.stat(object),\"\\n\")\n\t    cat(\"Type of penalty       :\", pen.type(object), \"with value,\",pen.value(object),\"\\n\")\n      cat(\"Minimum Segment Length :\", minseglen(object),\"\\n\")\n\t    cat(\"Maximum no. of cpts   :\", ncpts.max(object),\"\\n\")\n\t    if(length(cpts(object))<=20){cat(\"Changepoint Locations :\",cpts(object),\"\\n\")}\n\t    else{cat(\"Number of changepoints:\", ncpts(object),\"\\n\")}\n\t})\n\n\tsetMethod(\"summary\",\"cpt.range\",function(object){\n\t  cat(\"Created Using changepoint version\",object@version,'\\n')\n\t  cat(\"Changepoint type      : Change in\",cpttype(object),'\\n')\n\t  cat(\"Method of analysis    :\",method(object),\"\\n\")\n\t  cat(\"Test Statistic  :\", test.stat(object),\"\\n\")\n\t  cat(\"Type of penalty       :\", pen.type(object), \"with value,\",pen.value(object),\"\\n\")\n\t  cat(\"Minimum Segment Length :\", minseglen(object),\"\\n\")\n\t  cat(\"Maximum no. of cpts   :\", ncpts.max(object),\"\\n\")\n\t  if(length(cpts(object))<=20){cat(\"Changepoint Locations :\",cpts(object),\"\\n\")}\n\t  else{cat(\"Number of changepoints:\", ncpts(object),\"\\n\")}\n    if((nrow(cpts.full(object))<=5)&(ncol(cpts.full(object)<=20))){cat(\"Range of segmentations:\\n\");print(cpts.full(object));cat(\"\\n For penalty values:\", pen.value.full(object),\"\\n\")}\n    else{cat(\"Number of segmentations recorded:\", nrow(cpts.full(object)), \" with between \", sum(cpts.full(object)[nrow(cpts.full(object)),]>0,na.rm=T), \" and \", sum(cpts.full(object)[1,]>0,na.rm=T), \"changepoints.\\n Penalty value ranges from:\",min(pen.value.full(object)),\" to \",max(pen.value.full(object)))}\n\t})\n\n  setMethod(\"summary\",\"cpt.reg\",function(object){\n    cat(\"Created Using changepoint version\",object@version,'\\n')\n    cat(\"Changepoint type     : Change in\",cpttype(object),'\\n')\n\t    cat(\"Method of analysis   :\",method(object),\"\\n\")\n\t    cat(\"Test Statistic :\", test.stat(object),\"\\n\")\n\t    cat(\"Type of penalty      :\", pen.type(object), \"with value,\",pen.value(object),\"\\n\")\n\t    cat(\"Maximum no. of cpts   :\", ncpts.max(object),\"\\n\")\n\t    if(length(cpts(object))<=20){cat(\"Changepoint Locations :\",cpts(object),\"\\n\")}\n\t    else{cat(\"Number of changepoints:\", ncpts(object),\"\\n\")}\n\t})\n\n# show functions\n\tsetMethod(\"show\",\"cpt\",function(object){\n\t    cat(\"Class 'cpt' : Changepoint Object\\n\")\n\t    cat(\"       ~~   : S4 class containing\", length(attributes(object))-1, \"slots with names\\n\")\n\t    cat(\"             \", names(attributes(object))[1:(length(attributes(object))-1)], \"\\n\\n\")\n\t    cat(\"Created on  :\", object@date, \"\\n\\n\")\n\t    cat(\"summary(.)  :\\n----------\\n\")\n\t    summary(object)\n\t})\n\tsetMethod(\"show\",\"cpt.reg\",function(object){\n\t    cat(\"Class 'cpt.reg' : Changepoint Regression Object\\n\")\n\t    cat(\"       ~~   : S4 class containing\", length(attributes(object))-1, \"slots with names\\n\")\n\t    cat(\"             \", names(attributes(object))[1:(length(attributes(object))-1)], \"\\n\\n\")\n\t    cat(\"Created on  :\", object@date, \"\\n\\n\")\n\t    cat(\"summary(.)  :\\n----------\\n\")\n\t    summary(object)\n\t})\n\n# plot functions\n\tsetMethod(\"plot\",\"cpt\",function(x,cpt.col='red',cpt.width=1,cpt.style=1,...){\n\t  if(length(param.est(x))==0){# i.e. parameter.estimates=FALSE in call\n\t    cat('Calculating parameter estimates...')\n\t    object=param(x)\n\t    cat('done.\\n')\n\t  }\n\t\tplot(data.set.ts(x),...)\n\t\tif(cpttype(x)==\"variance\"){\n\t\t\tabline(v=index(data.set.ts(x))[cpts(x)],col=cpt.col,lwd=cpt.width,lty=cpt.style)\n\t\t}\n\t\telse if(cpttype(x)==\"mean\"  ||  cpttype(x)==\"mean and variance\"){\n\t\t\t#nseg=length(cpts(x))+1\n\t\t\tcpts=c(0,x@cpts)\n\t\t\tif((test.stat(x)==\"Normal\")||(test.stat(x)==\"CUSUM\")){\n\t\t\t\tmeans=param.est(x)$mean\n\t\t\t}\n\t\t\telse if(test.stat(x)==\"Gamma\"){\n\t\t\t\tmeans=param.est(x)$scale*param.est(x)$shape\n\t\t\t}\n\t\t\telse if(test.stat(x)==\"Exponential\"){\n\t\t\t\tmeans=1/param.est(x)$rate\n\t\t\t}\n\t\t\telse if(test.stat(x)==\"Poisson\"){\n\t\t\t  means=param.est(x)$lambda\n\t\t\t}\n\t\t\telse{\n\t\t\t\tstop('Invalid Changepoint test statistic')\n\t\t\t}\n\t\t\tfor(i in 1:nseg(x)){\n\t\t\t\tsegments(index(data.set.ts(x))[cpts[i]+1],means[i],index(data.set.ts(x))[cpts[i+1]],means[i],col=cpt.col,lwd=cpt.width,lty=cpt.style)\n\t\t\t}\n\t\t}\n\t  else if(cpttype(x)==\"trend\"){\n\t    cpts=c(0,x@cpts)\n\t    intercept=rep(param.est(x)$thetaS,x@cpts-c(0,cpts(x)))\n\t    slope=rep(param.est(x)$thetaT-param.est(x)$thetaS,x@cpts-c(0,cpts(x)))/rep(x@cpts-c(0,cpts(x)),x@cpts-c(0,cpts(x)))\n\t    cptn=rep(c(0,cpts(x)),x@cpts-c(0,cpts(x)))\n\t    n=length(data.set(x))\n\t    means=intercept+slope*((1:n)-cptn)\n\t    for(i in 1:nseg(x)){\n\t      segments(index(data.set.ts(x))[cpts[i]+1],means[cpts[i]+1],index(data.set.ts(x))[cpts[i+1]],means[cpts[i+1]],col=cpt.col,lwd=cpt.width,lty=cpt.style)\n\t    }\n\t  }\n\t\telse{\n\t\t\tstop('Invalid Changepoint Type for plotting.\\n Can only plot mean, variance, mean and variance')\n\t\t}\n\t})\n\n\tsetMethod(\"plot\",\"cpt.range\",function(x,ncpts=NA,diagnostic=FALSE,cpt.col='red',cpt.width=1,cpt.style=1,...){\n\t  if(diagnostic==TRUE){\n      return(plot(apply(cpts.full(x),1,function(x){sum(x>0,na.rm=TRUE)}),pen.value.full(x),type='l',xlab='Number of Changepoints',ylab='Difference in Test Statistic',...))\n\t  }\n\t  plot(data.set.ts(x),...)\n\t  if(is.na(ncpts)){\n\t    if(pen.type(x)==\"CROPS\"){\n\t      stop('CROPS does not supply an optimal set of changepoints, set ncpts to the desired segmentation to plot or use diagnostic=TRUE to identify an appropriate number of changepoints')\n\t    }\n\t    cpts.to.plot=cpts(x)\n\t    param.est=x\n\t  }\n\t  else{\n\t    ncpts.full=apply(cpts.full(x),1,function(x){sum(x>0,na.rm=TRUE)})\n\t    row=which(ncpts.full==ncpts)\n\t    if(length(row)==0){\n\t      stop(paste(\"Your input object doesn't have a segmentation with the requested number of changepoints.\\n Possible ncpts are: \"),paste(ncpts.full,collapse=','))\n\t    }\n\t    cpts.to.plot=cpts.full(x)[row,1:ncpts]\n\t    if(test.stat(x)==\"Gamma\"){\n\t      param.est=param(x,ncpts,shape=param.est(x)$shape)\n\t    }\n\t    else{\n\t      param.est=param(x,ncpts)\n\t    }\n\t  }\n\t  if(cpttype(x)==\"variance\"){\n\t    abline(v=index(data.set.ts(x))[cpts.to.plot],col=cpt.col,lwd=cpt.width,lty=cpt.style)\n\t  }\n\t  else if(cpttype(x)==\"mean\"  ||  cpttype(x)==\"mean and variance\"){\n\t    if((test.stat(x)==\"Normal\")||(test.stat(x)==\"CUSUM\")){\n\t      means=param.est(param.est)$mean\n\t    }\n\t    else if(test.stat(x)==\"Gamma\"){\n\t      means=param.est(param.est)$scale*param.est(param.est)$shape\n\t    }\n\t    else if(test.stat(x)==\"Exponential\"){\n\t      means=1/param.est(param.est)$rate\n\t    }\n\t    else if(test.stat(x)==\"Poisson\"){\n\t      means=param.est(param.est)$lambda\n\t    }\n\t    else{\n\t      stop('Invalid Changepoint test statistic')\n\t    }\n\t    nseg=ncpts+1\n\t    cpts.to.plot=c(0,cpts.to.plot,length(data.set(x)))\n\t    for(i in 1:nseg){\n\t      segments(index(data.set.ts(x))[cpts.to.plot[i]+1],means[i],index(data.set.ts(x))[cpts.to.plot[i+1]],means[i],col=cpt.col,lwd=cpt.width,lty=cpt.style)\n\t    }\n\t  }\n\t  else{\n\t    stop('Invalid Changepoint Type for plotting.\\n Can only plot mean, variance, mean and variance')\n\t  }\n\t})\n\t\n\tsetMethod(\"plot\",\"cpt.reg\",function(x,cpt.col='red',cpt.width=1,cpt.style=1,...){\n\t  if(length(param.est(x))==0){# i.e. parameter.estimates=FALSE in call\n\t    cat('Calculating parameter estimates...')\n\t    object=param(x)\n\t    cat('done.\\n')\n\t  }\n\t  plot(data.set(x)[,1],type='l',...)\n\t  if(test.stat(x)==\"Normal\"){\n\t    cpts=c(0,x@cpts)\n\t    betas=param.est(x)$beta\n\t    for(i in 1:nseg(x)){\n\t      lines((cpts[i]+1):cpts[i+1],betas[i,]%*%t(data.set(x)[(cpts[i]+1):cpts[i+1],-1]),col=cpt.col,lwd=cpt.width,lty=cpt.style)\n\t    }\n\t  }\n\t  else{\n\t    stop('Invalid Changepoint test statistic')\n\t  }\n\t})\n\n# likelihood functions\n\tsetMethod(\"logLik\", \"cpt\", function(object) {\n\t  if(length(param.est(object))==0){# i.e. parameter.estimates=FALSE in call\n\t    cat('Calculating parameter estimates...')\n\t    object=param(object)\n\t    cat('done.\\n')\n\t  }\n\t\tif(test.stat(object)==\"Normal\"){\n\t\t\tif(cpttype(object)==\"mean\"){\n        means=rep(param.est(object)$mean,object@cpts-c(0,cpts(object)))\n        rss=sum((data.set(object)-means)^2)\n        n=length(data.set(object))\n        like=n*(log(2*pi)+log(rss/n)+1) # -2*loglik\n        if(pen.type(object)==\"MBIC\"){\n          like=c(like, like+(nseg(object)-2)*pen.value(object)+sum(log(seg.len(object))))\n        }else{\n\t\t\t\t  like=c(tmplike,tmplike+(nseg(object)-1)*pen.value(object))\n        }\n\t\t\t}\n\t\t\telse if(cpttype(object)==\"variance\"){\n        rss=c(0,cumsum((data.set(object)-param.est(object)$mean)^2))\n        cpts=c(0,object@cpts)\n        n=length(data.set(object))\n        seglen=seg.len(object)\n        sigmas=(rss[cpts[-1]+1]-rss[cpts[-length(cpts)]+1])/seglen\n        like=n*log(2*pi)+sum(seglen*log(sigmas))+n\n\t\t\t\tif(pen.type(object)==\"MBIC\"){\n\t\t\t\t  like=c(like, like+(nseg(object)-2)*pen.value(object)+sum(log(seglen)))\n\t\t\t\t}else{\n\t\t\t\t  like=c(like,like+(nseg(object)-1)*pen.value(object))\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if(cpttype(object)==\"mean and variance\"){\n\t\t\t  means=rep(param.est(object)$mean,object@cpts-c(0,cpts(object)))\n\t\t\t  rss=sum((data.set(object)-means)^2)\n\t\t\t  n=length(data.set(object))\n\t\t\t  cpts=c(0,object@cpts)\n\t\t\t  seglen=seg.len(object)\n\t\t\t  sigmas=param.est(object)$variance\n\t\t\t  like=n*log(2*pi)+sum(seglen*log(sigmas))+n\n\t\t\t\tif(pen.type(object)==\"MBIC\"){\n\t\t\t\t  like=c(like,like+(nseg(object)-2)*pen.value(object)+sum(log(seglen)))\n\t\t\t\t}else{\n\t\t\t\t  like=c(like,like+(nseg(object)-1)*pen.value(object))\n\t\t\t\t}\n\t\t\t}\n\t\t  else if(cpttype(object)==\"trend\"){\n\t\t    intercept=rep(param.est(object)$thetaS,object@cpts-c(0,cpts(object)))\n\t\t    slope=rep(param.est(object)$thetaT-param.est(object)$thetaS,object@cpts-c(0,cpts(object)))/rep(object@cpts-c(0,cpts(object)),object@cpts-c(0,cpts(object)))\n\t\t    cptn=rep(c(0,cpts(object)),object@cpts-c(0,cpts(object)))\n\t\t    n=length(data.set(object))\n\t\t    means=intercept+slope*((1:n)-cptn)\n\t\t    rss=sum((data.set(object)-means)^2)\n\t\t    like=n*(log(2*pi)+log(rss/n)+1) # -2*loglik\n\t\t    if(pen.type(object)==\"MBIC\"){\n\t\t      like=c(like, like+(nseg(object)-2)*pen.value(object)+sum(log(seg.len(object))))\n\t\t    }else{\n\t\t      like=c(like,like+(nseg(object)-1)*pen.value(object))\n\t\t    }\n\t\t  }\n\t\t  else if(cpttype(object)==\"trendar\"){\n\t\t    seglen=seg.len(object)\n\t\t    intercept=rep(param.est(object)$thetaj,seglen)\n\t\t    slope=rep(param.est(object)$thetajpo-param.est(object)$thetaj,seglen)/rep(seglen,seglen)\n\t\t    ar=rep(param.est(object)$beta,seglen)\n\t\t    cptn=rep(c(0,cpts(object)),seglen)\n\t\t    n=length(data.set(object))\n\t\t    means=NULL;means[1]=0\n\t\t    for(i in 2:n){means[i]=intercept+slope*((1:n)-cptn)+ar*means[i-1]}\n\t\t    means=means[-1]\n\t\t    rss=sum((data.set(object)[-1]-means)^2)\n\t\t    like=n*(log(2*pi)+log(rss/n)+1) # -2*loglik\n\t\t    if(pen.type(object)==\"MBIC\"){\n\t\t      like=c(like, like+(nseg(object)-2)*pen.value(object)+sum(log(seg.len(object))))\n\t\t    }else{\n\t\t      like=c(like,like+(nseg(object)-1)*pen.value(object))\n\t\t    }\n\t\t  }\n\t\t  else if(cpttype(object)==\"meanar\"){\n\t\t    seglen=seg.len(object)\n\t\t    intercept=rep(param.est(object)$beta1,seglen)\n\t\t    ar=rep(param.est(object)$beta2,seglen)\n\t\t    cptn=rep(c(0,cpts(object)),seglen)\n\t\t    n=length(data.set(object))\n\t\t    means[1]=0;for(i in 2:n){means[i]=intercept+ar*means[i-1]}\n\t\t    means=means[-1]\n\t\t    rss=sum((data.set(object)[-1]-means)^2)\n\t\t    like=n*(log(2*pi)+log(rss/n)+1) # -2*loglik\n\t\t    if(pen.type(object)==\"MBIC\"){\n\t\t      like=c(like, like+(nseg(object)-2)*pen.value(object)+sum(log(seg.len(object))))\n\t\t    }else{\n\t\t      like=c(like,like+(nseg(object)-1)*pen.value(object))\n\t\t    }\n\t\t  }\n\t\t\telse{\n\t\t\t\tstop(\"Unknown changepoint type, must be 'mean', 'variance', 'mean and variance', 'trend', 'meanar' or 'trendar'\")\n\t\t\t}\n\t\t}\n\t\telse if(test.stat(object)==\"Gamma\"){\n\t\t\tif(cpttype(object)!=\"mean and variance\"){\n\t\t\t\tstop(\"Unknown changepoint type for test.stat='Gamma', must be 'mean and variance'\")\n\t\t\t}\n\t\t\telse{\n\t\t\t  warning(\"Not changed to be -2*logLik\")\n\t\t\t  mll.meanvarg=function(x,n,shape){\n\t\t\t    return(n*shape*log(n*shape)-n*shape*log(x))\n\t\t\t  }\n\t\t\t\ty=c(0,cumsum(data.set(object)))\n\t\t\t\tshape=param.est(object)$shape\n\t\t\t\tcpts=c(0,object@cpts)\n\t\t\t\t#nseg=length(cpts)-1\n\t\t\t\ttmplike=0\n\t\t\t\tfor(j in 1:nseg(object)){\n\t\t\t\t\ttmplike=tmplike+mll.meanvarg(y[cpts[j+1]+1]-y[cpts[j]+1],cpts[j+1]-cpts[j],shape)\n\t\t\t\t}\n\t\t\t\tif(pen.type(object)==\"MBIC\"){\n\t\t\t\t  like=c(tmplike, tmplike+(nseg(object)-2)*pen.value(object)+sum(log(seg.len(object))))\n\t\t\t\t}else{\n\t\t\t\t  like=c(tmplike,tmplike+(nseg(object)-1)*pen.value(object))\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse if(test.stat(object)==\"Exponential\"){\n\t\t\tif(cpttype(object)!=\"mean and variance\"){\n\t\t\t\tstop(\"Unknown changepoint type for test.stat='Exponential', must be 'mean and variance'\")\n\t\t\t}\n\t\t\telse{\n\t\t\t  warning(\"Not changed to be -2*logLik\")\n\t\t\t  mll.meanvare=function(x,n){\n\t\t\t    return(n*log(n)-n*log(x))\n\t\t\t  }\n\t\t\t\ty=c(0,cumsum(data.set(object)))\n\t\t\t\tcpts=c(0,object@cpts)\n\t\t\t\t#nseg=length(cpts)-1\n\t\t\t\ttmplike=0\n\t\t\t\tfor(j in 1:nseg(object)){\n\t\t\t\t\ttmplike=tmplike+mll.meanvare(y[cpts[j+1]+1]-y[cpts[j]+1],cpts[j+1]-cpts[j])\n\t\t\t\t}\n\t\t\t\tif(pen.type(object)==\"MBIC\"){\n\t\t\t\t  like=c(tmplike, tmplike+(nseg(object)-2)*pen.value(object)+sum(log(seg.len(object))))\n\t\t\t\t}else{\n\t\t\t\t  like=c(tmplike,tmplike+(nseg(object)-1)*pen.value(object))\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse if(test.stat(object)==\"Poisson\"){\n\t\t  if(cpttype(object)!=\"mean and variance\"){\n\t\t    stop(\"Unknown changepoint type for test.stat='Poisson', must be 'mean and variance'\")\n\t\t  }\n\t\t  else{\n\t\t    warning(\"Not changed to be -2*logLik\")\n\t\t    mll.meanvarp=function(x,n){\n\t\t      return(x*log(x)-x*log(n))\n\t\t    }\n\t\t    y=c(0,cumsum(data.set(object)))\n\t\t    cpts=c(0,object@cpts)\n\t\t    #nseg=length(cpts)-1\n\t\t    tmplike=0\n\t\t    for(j in 1:nseg(object)){\n\t\t      tmplike=tmplike+mll.meanvarp(y[cpts[j+1]+1]-y[cpts[j]+1],cpts[j+1]-cpts[j])\n\t\t    }\n\t\t    if(pen.type(object)==\"MBIC\"){\n\t\t      like=c(tmplike, tmplike+(nseg(object)-2)*pen.value(object)+sum(log(seg.len(object))))\n\t\t    }else{\n\t\t      like=c(tmplike,tmplike+(nseg(object)-1)*pen.value(object))\n\t\t    }\n\t\t  }\n\t\t}\n\t\telse{stop(\"logLik is only valid for distributional assumptions, not CUSUM or CSS\")}\n\t  names(like)=c(\"-like\",\"-likepen\")\n\t  return(like)\n\t})\n\n\tsetMethod(\"logLik\", \"cpt.range\", function(object,ncpts=NA) {\n\t  warning(\"Not changed to be -2*logLik\")\n\t  if(is.na(ncpts)){\n\t    if(pen.type(object)==\"CROPS\"){\n\t      stop('CROPS does not supply an optimal set of changepoints, set ncpts argument to the desired segmentation to plot or use diagnostic=TRUE to identify an appropriate number of changepoints')\n\t    }\n\t    cpts=c(0,object@cpts)\n      pen.value=pen.value(object)\n\t  }\n\t  else{\n\t    ncpts.full=apply(cpts.full(object),1,function(x){sum(x>0,na.rm=TRUE)})\n\t    row=which(ncpts.full==ncpts)\n\t    if(length(row)==0){\n\t      stop(paste(\"Your input object doesn't have a segmentation with the requested number of changepoints.\\n Possible ncpts are: \"),paste(ncpts.full,collapse=','))\n\t    }\n\t    cpts=c(0,cpts.full(object)[row,1:ncpts],length(data.set(object)))\n      pen.value=pen.value.full(object)[row]\n\t  }\n\t  nseg=length(cpts)-1\n\t  \n\t  if(test.stat(object)==\"Normal\"){\n\t    if(cpttype(object)==\"mean\"){\n\t      mll.mean=function(x2,x,n){\n\t        return( x2-(x^2)/n)\n\t      }\n\t      y2=c(0,cumsum(data.set(object)^2))\n\t      y=c(0,cumsum(data.set(object)))\n\t      tmplike=0\n\t      for(j in 1:nseg){\n\t        tmplike=tmplike+mll.mean(y2[cpts[j+1]+1]-y2[cpts[j]+1],y[cpts[j+1]+1]-y[cpts[j]+1],cpts[j+1]-cpts[j])\n\t      }\n\t      ##c(tmplike, tmplike+(nseg-2)*pen.value(object)+sum(log(cpts[-1]-cpts[-(nseg+1)])))\n\t      if(pen.type(object)==\"MBIC\"){\n\t        like=c(tmplike, tmplike+(nseg-2)*pen.value+sum(log(seg.len(object))))\n\t      }else{\n\t        like=c(tmplike,tmplike+(nseg-1)*pen.value)\n\t      }\n\t      names(like)=c(\"-like\",\"-likepen\")\n\t    }\n\t    else if(cpttype(object)==\"variance\"){\n\t      mll.var=function(x,n){\n\t        neg=x<=0\n\t        x[neg==TRUE]=0.00000000001    \n\t        return( n*(log(2*pi)+log(x/n)+1))\n\t      }\n\t      y2=c(0,cumsum((data.set(object)-param.est(object)$mean)^2))\n\t      tmplike=0\n\t      for(j in 1:nseg){\n\t        tmplike=tmplike+mll.var(y2[cpts[j+1]+1]-y2[cpts[j]+1],cpts[j+1]-cpts[j])\n\t      }\n\t      if(pen.type(object)==\"MBIC\"){\n\t        like=c(tmplike, tmplike+(nseg-2)*pen.value+sum(log(seg.len(object))))\n\t      }else{\n\t        like=c(tmplike,tmplike+(nseg-1)*pen.value)\n\t      }\n\t      names(like)=c(\"-like\",\"-likepen\")\n\t    }\n\t    else if(cpttype(object)==\"mean and variance\"){\n\t      mll.meanvar=function(x2,x,n){\n\t        sigmasq=(1/n)*(x2-(x^2)/n)\n\t        neg=sigmasq<=0\n\t        sigmasq[neg==TRUE]=0.00000000001\n\t        return( n*(log(2*pi)+log(sigmasq)+1))\n\t      }\n\t      y2=c(0,cumsum(data.set(object)^2))\n\t      y=c(0,cumsum(data.set(object)))\n\t      tmplike=0\n\t      for(j in 1:nseg){\n\t        tmplike=tmplike+mll.meanvar(y2[cpts[j+1]+1]-y2[cpts[j]+1],y[cpts[j+1]+1]-y[cpts[j]+1],cpts[j+1]-cpts[j])\n\t      }\n\t      if(pen.type(object)==\"MBIC\"){\n\t        like=c(tmplike, tmplike+(nseg-2)*pen.value+sum(log(seg.len(object))))\n\t      }else{\n\t        like=c(tmplike,tmplike+(nseg-1)*pen.value)\n\t      }\n\t      names(like)=c(\"-like\",\"-likepen\")\n\t    }\n\t    else{\n\t      stop(\"Unknown changepoint type, must be 'mean', 'variance' or 'mean and variance'\")\n\t    }\n\t  }\n\t  else if(test.stat(object)==\"Gamma\"){\n\t    if(cpttype(object)!=\"mean and variance\"){\n\t      stop(\"Unknown changepoint type for test.stat='Gamma', must be 'mean and variance'\")\n\t    }\n\t    else{\n\t      mll.meanvarg=function(x,n,shape){\n\t        return(n*shape*log(n*shape)-n*shape*log(x))\n\t      }\n\t      y=c(0,cumsum(data.set(object)))\n\t      shape=param.est(object)$shape\n\t      cpts=c(0,object@cpts)\n\t      #nseg=length(cpts)-1\n\t      tmplike=0\n\t      for(j in 1:nseg){\n\t        tmplike=tmplike+mll.meanvarg(y[cpts[j+1]+1]-y[cpts[j]+1],cpts[j+1]-cpts[j],shape)\n\t      }\n\t      if(pen.type(object)==\"MBIC\"){\n\t        like=c(tmplike, tmplike+(nseg-2)*pen.value+sum(log(seg.len(object))))\n\t      }else{\n\t        like=c(tmplike,tmplike+(nseg-1)*pen.value)\n\t      }\n\t      names(like)=c(\"-like\",\"-likepen\")\n\t    }\n\t  }\n\t  else if(test.stat(object)==\"Exponential\"){\n\t    if(cpttype(object)!=\"mean and variance\"){\n\t      stop(\"Unknown changepoint type for test.stat='Exponential', must be 'mean and variance'\")\n\t    }\n\t    else{\n\t      mll.meanvare=function(x,n){\n\t        return(n*log(n)-n*log(x))\n\t      }\n\t      y=c(0,cumsum(data.set(object)))\n\t      cpts=c(0,object@cpts)\n\t      #nseg=length(cpts)-1\n\t      tmplike=0\n\t      for(j in 1:nseg){\n\t        tmplike=tmplike+mll.meanvare(y[cpts[j+1]+1]-y[cpts[j]+1],cpts[j+1]-cpts[j])\n\t      }\n\t      if(pen.type(object)==\"MBIC\"){\n\t        like=c(tmplike, tmplike+(nseg-2)*pen.value+sum(log(seg.len(object))))\n\t      }else{\n\t        like=c(tmplike,tmplike+(nseg-1)*pen.value)\n\t      }\n\t      names(like)=c(\"-like\",\"-likepen\")\n\t    }\n\t  }\n\t  else if(test.stat(object)==\"Poisson\"){\n\t    if(cpttype(object)!=\"mean and variance\"){\n\t      stop(\"Unknown changepoint type for test.stat='Poisson', must be 'mean and variance'\")\n\t    }\n\t    else{\n\t      mll.meanvarp=function(x,n){\n\t        return(x*log(x)-x*log(n))\n\t      }\n\t      y=c(0,cumsum(data.set(object)))\n\t      cpts=c(0,object@cpts)\n\t      #nseg=length(cpts)-1\n\t      tmplike=0\n\t      for(j in 1:nseg){\n\t        tmplike=tmplike+mll.meanvarp(y[cpts[j+1]+1]-y[cpts[j]+1],cpts[j+1]-cpts[j])\n\t      }\n\t      if(pen.type(object)==\"MBIC\"){\n\t        like=c(tmplike, tmplike+(nseg-2)*pen.value+sum(log(seg.len(object))))\n\t      }else{\n\t        like=c(tmplike,tmplike+(nseg-1)*pen.value)\n\t      }\n\t      names(like)=c(\"-like\",\"-likepen\")\n\t    }\n\t  }\n\t  else{stop(\"logLik is only valid for distributional assumptions, not CUSUM or CSS\")}\n\t  return(like)\n\t})\n\n\tsetMethod(\"logLik\", \"cpt.reg\", function(object) {\n\t  if(length(param.est(object))==0){# i.e. parameter.estimates=FALSE in call\n\t    cat('Calculating parameter estimates...')\n\t    object=param(object)\n\t    cat('done.\\n')\n\t  }\n\t  if(test.stat(object)==\"Normal\"){\n\t    cpts=c(0,object@cpts)\n\t    seglen=seg.len(object)\n\t    data=data.set(object)\n\t    beta=param.est(object)$beta\n\t    sigmas=param.est(object)$sig2\n\t    rss=NULL\n\t    for(i in 1:length(seglen)){\n\t      rss[i]=sum((data[(cpts[i]+1):cpts[i+1],1]-data[(cpts[i]+1):cpts[i+1],-1]%*%beta[i,])^2)\n\t    }\n      like=sum(seglen*log(2*pi*sigmas))+sum(rss/sigmas)\n      if(pen.type(object)==\"MBIC\"){\n        like=c(like, like+(nseg(object)-2)*pen.value(object)+sum(log(seg.len(object))))\n      }else{\n        like=c(tmplike,tmplike+(nseg(object)-1)*pen.value(object))\n      }\n\t  }\n\t  else{stop(\"logLik is only valid for Normal distributional assumption.\")}\n\t  return(like)\n\t})\n\t\n\tsetGeneric(\"likelihood\", function(object) standardGeneric(\"likelihood\"))\n\tsetMethod(\"likelihood\", \"cpt\", function(object) {\n\t\treturn(logLik(object))\n\t})\n\n# acf functions\n\tsetGeneric(\"acf\", function(object,...) standardGeneric(\"acf\"))\n\tsetMethod(\"acf\", \"cpt\", function(object,lag.max=NULL,...) {\n    cpts=c(0,object@cpts)\n    nseg=nseg(object)\n    data=data.set(object)\n    for(i in 1:nseg){\n      stats::acf(data[(cpts[i]+1):cpts[i+1]],main=paste(\"Series part:\",(cpts[i]+1),\":\",cpts[i+1]),...)\n    }\n\t})\n\t\n\tsetMethod(\"acf\", \"cpt.reg\", function(object,lag.max=NULL,...) {\n\t  cpts=c(0,object@cpts)\n\t  nseg=nseg(object)\n\t  data=data.set(object)[,1]\n\t  for(i in 1:nseg){\n\t    stats::acf(data[(cpts[i]+1):cpts[i+1]],main=paste(\"Series part:\",(cpts[i]+1),\"-\",cpts[i+1]),...)\n\t  }\n\t})\n\t",
    "created" : 1458558502649.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "4259415845",
    "id" : "7021A46",
    "lastKnownWriteTime" : 1458486832,
    "path" : "~/Dropbox/Becki-Matt/changepoint.online/R/cpt.class.R",
    "project_path" : "R/cpt.class.R",
    "properties" : {
    },
    "relative_order" : 2,
    "source_on_save" : false,
    "type" : "r_source"
}